# Pattern Induction Configuration Format

**Version:** 1.0
**Status:** Design Specification
**Last Updated:** October 31, 2025

---

## Overview

This document specifies the configuration format for AlterX's pattern induction feature. The format is designed as a **backward-compatible extension** to the existing `permutations.yaml` format, adding support for:

1. **Root metadata** - CLI version and generation statistics
2. **Token dictionary** - Semantic classification of common payload types
3. **Learned patterns** - Patterns discovered through pattern induction with quality metrics
4. **Pattern-scoped payloads** - Inline payload definitions for unknown tokens
5. **Auto-classification** - Automatic matching of discovered payloads to known token types

---

## Design Principles

### 1. Backward Compatibility ✓
- Existing `patterns` and `payloads` sections remain unchanged
- Tools using the old format continue to work without modification
- New sections are additive, not breaking

### 2. Self-Contained Patterns
- Each learned pattern includes all necessary information
- Patterns can be understood and used independently
- No global namespace pollution from auto-generated names

### 3. Progressive Enhancement
- Unknown payloads start with positional names (`p0`, `p1`, `p2`)
- Users can promote common patterns to `token_dictionary`
- System learns from user classifications over time

### 4. Extensibility
- Users can add custom token types via `custom_tokens`
- Pattern families support large-scale organization
- Metadata tracking for auditing and debugging

---

## Configuration Structure

```yaml
# ============================================================================
# SECTION 1: EXISTING FORMAT (unchanged)
# ============================================================================
patterns:
  - "{{word}}-{{sub}}.{{suffix}}"
  - "{{sub}}-{{word}}.{{suffix}}"

payloads:
  word: [api, web, cdn]
  number: [1, 2, 3]
  region: [us-east-1, us-west-2]

# ============================================================================
# SECTION 2: PATTERN INDUCTION EXTENSIONS (new)
# ============================================================================

## Root Metadata (embedded in comments at section header)
## Generated by: alterx v0.1.0
## Input domains: 1000
## Patterns generated: 15

## Token Dictionary - Known semantic types (directly extensible)
token_dictionary:
  env:
    description: "Environment identifiers"
    values: [dev, prod, staging, qa]

  region:
    description: "Cloud region identifiers"
    values: [us-east-1, us-west-2, eu-central-1]

## Learned Patterns - Pattern induction results
learned_patterns:
  - id: pattern_001
    template: "{{service}}-{{env}}-{{number}}.{{suffix}}"
    coverage: 450
    ratio: 1.2
    confidence: 0.84

  - id: pattern_002
    template: "{{service}}-{{p0}}.{{suffix}}"
    coverage: 230
    ratio: 2.1
    confidence: 0.52
    payloads:
      p0:
        values: [alpha, beta, gamma]
        examples:
          - api-alpha.example.com
          - web-beta.example.com
```

---

## Token Dictionary Specification

### Purpose
Define known semantic token types that can be auto-classified during pattern learning. This dictionary is directly extensible - users can add domain-specific token types directly to this section.

### Structure

```yaml
token_dictionary:
  <token_name>:
    description: string       # Human-readable description
    values: [string, ...]    # List of known values
```

### Built-in Token Types

| Token Name | Description | Example Values |
|------------|-------------|----------------|
| `env` | Environment identifiers | dev, prod, staging, qa |
| `region` | Cloud regions | us-east-1, eu-central-1 |
| `service` | Service names | api, web, cdn, db |
| `version` | API versions | v1, v2, alpha, beta |
| `visibility` | Network access | internal, external, private |
| `database_type` | DB systems | mysql, postgres, redis |

### Classification Algorithm

**Input:** Discovered payload values `[value1, value2, ...]`
**Output:** Token name OR positional name (`p0`, `p1`, etc.)

**Algorithm:**
```python
for each token_type in token_dictionary:
    matched = intersection(discovered_values, token_type.values)
    overlap_ratio = len(matched) / len(discovered_values)
    specificity = calculate_specificity(discovered_values)

    score = (overlap_ratio * 0.7) + (specificity * 0.3)

    if score >= 0.7:
        return token_type.name  # Classify as this type

return f"p{position}"  # Use positional naming
```

### Confidence Formula

**Purpose:** Calculate quality score indicating what percentage of generated subdomains will be valid.

**Formula:**
```python
# Base score from ratio (85% weight)
ratio_score = 1.0 / ratio
# where ratio = possible_generations / observed_count

# Coverage adjustment (15% weight, logarithmic scale)
coverage_score = min(1.0, log10(coverage) / 3.0)

# Final confidence
confidence = (0.85 * ratio_score) + (0.15 * coverage_score)
```

**Interpretation:**
- Confidence of 0.84 → 84% of generated subdomains will be valid
- Higher is better (closer to 1.0)
- Ratio is the primary signal (85%), coverage provides minor adjustment (15%)

**Examples:**

| Coverage | Ratio | Ratio Score | Coverage Score | Confidence | Interpretation |
|----------|-------|-------------|----------------|------------|----------------|
| 450      | 1.2   | 0.83        | 0.88           | **0.84**   | 84% valid - excellent |
| 230      | 2.1   | 0.48        | 0.79           | **0.53**   | 53% valid - moderate |
| 85       | 3.2   | 0.31        | 0.64           | **0.36**   | 36% valid - low quality |
| 10       | 1.5   | 0.67        | 0.33           | **0.62**   | Low coverage penalty |
| 1000     | 1.5   | 0.67        | 1.00           | **0.72**   | High coverage boost |

### Classification Rules

**Auto-classify if:**

1. **Multiple matches (≥2) with good overlap (≥70%)**
   ```yaml
   Discovered: [dev, prod, staging]
   Matches: env (3/3 = 100%)
   Result: ✓ Classify as "env"
   ```

2. **Single match BUT highly specific (specificity ≥0.8)**
   ```yaml
   Discovered: [us-east-1]
   Matches: region (1/1 = 100%, AWS region pattern)
   Result: ✓ Classify as "region"
   ```

**Do NOT auto-classify if:**

3. **Single generic match**
   ```yaml
   Discovered: [prod]
   Matches: env (1/1 = 100% BUT too generic)
   Result: ✗ Use positional "p0"
   ```

4. **Poor overlap (<70%)**
   ```yaml
   Discovered: [dev, prod, foo, bar]
   Matches: env (2/4 = 50%)
   Result: ✗ Use positional "p0"
   ```

### Specificity Scoring

Values are scored based on patterns:

| Pattern | Specificity | Example |
|---------|-------------|---------|
| AWS region format | 1.0 | `us-east-1` |
| Versioned format | 1.0 | `api-v2-alpha` |
| UUID format | 1.0 | `550e8400-e29b-41d4-a716-446655440000` |
| Date format | 0.8 | `2025-10-31` |
| Hyphenated words | 0.5 | `foo-bar` |
| Generic words | 0.3 | `prod`, `api`, `test` |

---

## Learned Patterns Specification

### Purpose
Store patterns discovered through pattern induction with all necessary metadata and inline payloads.

### Structure

```yaml
learned_patterns:
  - id: string              # Unique identifier (e.g., "pattern_001")
    template: string        # Pattern template with {{variables}}
    coverage: int           # Number of input domains matched
    ratio: float            # Possible generations / observed count
    confidence: float       # Quality score (0.0-1.0, higher is better)
    payloads:              # Optional - only for unknown tokens
      <token_name>:
        values: [string, ...]
        examples: [string, ...]  # Optional example domains
```

### Template Variables

Templates can reference three types of variables:

1. **Token dictionary entries**
   ```yaml
   template: "{{service}}-{{env}}.{{suffix}}"
   # Uses values from token_dictionary
   ```

2. **Positional payloads** (unknown tokens)
   ```yaml
   template: "{{p0}}-{{p1}}.{{suffix}}"
   payloads:
     p0: [foo, bar, baz]
     p1: [x, y, z]
   ```

3. **Built-in variables** (from AlterX)
   - `{{sub}}` - Original subdomain
   - `{{suffix}}` - Domain suffix
   - `{{tld}}` - Top-level domain
   - `{{root}}` - Root domain

### Examples

#### Example 1: Pattern with known tokens
```yaml
- id: pattern_001
  template: "{{service}}-{{env}}-{{number}}.{{suffix}}"
  coverage: 450
  ratio: 1.2
  confidence: 0.84
  # No payloads - uses token_dictionary
```

**Generates:**
- `api-dev-01.example.com`
- `web-prod-02.example.com`
- `cdn-staging-03.example.com`

**Quality:** Excellent (84% of generations will be valid)

#### Example 2: Pattern with mixed known/unknown tokens
```yaml
- id: pattern_002
  template: "{{service}}-{{p0}}.{{suffix}}"
  coverage: 230
  ratio: 2.1
  confidence: 0.53
  payloads:
    p0:
      values: [alpha, beta, gamma, delta]
      examples:
        - api-alpha.example.com
        - web-beta.example.com
```

**Generates:**
- `api-alpha.example.com`
- `api-beta.example.com`
- `web-alpha.example.com`

**Quality:** Moderate (53% of generations will be valid)

#### Example 3: Pattern with all unknown tokens
```yaml
- id: pattern_003
  template: "{{p0}}-{{p1}}-{{p2}}.{{suffix}}"
  coverage: 85
  ratio: 3.2
  confidence: 0.36
  payloads:
    p0: [foo, bar, baz]
    p1: [red, blue, green]
    p2: [x, y, z]
```

**Quality:** Low (36% of generations will be valid - use with caution or filter with --min-confidence)

**Generates:**
- `foo-red-x.example.com`
- `foo-red-y.example.com`
- `bar-blue-z.example.com`
- ... (3 × 3 × 3 = 27 combinations)

---

## Payload Promotion Workflow

### Problem
Over time, users notice patterns in positional payloads that should be semantic tokens.

### Solution: Manual Promotion to Token Dictionary

```yaml
# Step 1: Pattern initially learned with unknown payload
learned_patterns:
  - id: pattern_042
    template: "{{service}}-{{p0}}.{{suffix}}"
    payloads:
      p0: [internal, external, private, public]

# Step 2: User recognizes this as "visibility" and adds to token_dictionary
token_dictionary:
  visibility:
    description: "Network visibility"
    values: [internal, external, private, public]

# Step 3: Re-run pattern induction OR manually update pattern
learned_patterns:
  - id: pattern_042
    template: "{{service}}-{{visibility}}.{{suffix}}"
    # No payloads section - now uses token_dictionary
```

### Workflow
1. Observe positional payloads in learned_patterns
2. Manually add new token type to token_dictionary
3. Either re-run pattern induction or manually update pattern template

---

## Configuration Loading Priority

When loading configurations, the following priority applies:

1. **Token dictionary** (extensible by users)
2. **Learned patterns** (generated by pattern induction)
3. **Manual patterns** (user-defined patterns)

---

## Backward Compatibility Guarantees

### What is guaranteed:
- ✓ Existing `patterns` section continues to work
- ✓ Existing `payloads` section continues to work
- ✓ Tools using old format see no changes
- ✓ New sections are ignored by old parsers

### What changes:
- New sections are added to the schema
- Pattern induction mode populates new sections
- Users can optionally use new features

### Migration path:
```
Old format → Still works, no migration needed
New format → Opt-in via pattern induction mode
Mixed format → Both work together seamlessly
```

---

## Implementation Notes

### Go Struct Definitions

```go
// Config represents the complete permutations.yaml structure
type Config struct {
    // Existing format (backward compatible)
    Patterns []string                `yaml:"patterns"`
    Payloads map[string][]string     `yaml:"payloads"`

    // Pattern induction extensions
    TokenDictionary  map[string]TokenDefinition   `yaml:"token_dictionary,omitempty"`
    LearnedPatterns  []LearnedPattern             `yaml:"learned_patterns,omitempty"`
}

type TokenDefinition struct {
    Description string   `yaml:"description"`
    Values      []string `yaml:"values"`
}

type LearnedPattern struct {
    ID          string                `yaml:"id"`
    Template    string                `yaml:"template"`
    Coverage    int                   `yaml:"coverage"`
    Ratio       float64               `yaml:"ratio"`
    Confidence  float64               `yaml:"confidence"`
    Payloads    map[string]PayloadDef `yaml:"payloads,omitempty"`
}

type PayloadDef struct {
    Values   []string `yaml:"values,omitempty"`
    Examples []string `yaml:"examples,omitempty"`
}
```

---

## Summary

This configuration format provides:

1. **Backward compatibility** - No breaking changes to existing format
2. **Auto-classification** - Intelligent matching of payloads to semantic types
3. **Self-contained patterns** - Each pattern includes all necessary information
4. **Quality metrics** - Coverage, ratio, and confidence scores for pattern filtering
5. **Extensibility** - Token dictionary is directly extensible by users
6. **Simplicity** - Minimal structure with only essential fields

The format balances simplicity (positional names by default) with intelligence (auto-classification when confident), allowing the system to work effectively for both small and large-scale pattern learning scenarios.

**Key Design Decisions:**
- Root-level metadata embedded in comments
- No separate custom_tokens (use token_dictionary directly)
- No pattern_families (YAGNI - add later if needed)
- No complex metadata tracking (version + counts only)
- Confidence formula: 85% ratio + 15% coverage adjustment

---

**Next Steps:**
- Implement Go structs and YAML parsing
- Implement classification algorithm with specificity scoring
- Implement confidence calculation formula
- Write comprehensive tests
